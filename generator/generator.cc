// Copyright 2013
// Author: Christopher Van Arsdale

#include <set>
#include <vector>
#include <string>
#include "common/log/log.h"
#include "repobuild/env/input.h"
#include "repobuild/generator/generator.h"
#include "nodes/node.h"
#include "repobuild/reader/parser.h"

using std::string;
using std::vector;
using std::set;

namespace repobuild {
namespace {

void GetFullDepList(const Parser& parser,
                    const Node* node,
                    set<const Node*>* parents,
                    vector<const Node*>* deps) {
  for (int i = 0; i < node->dependencies().size(); ++i) {
    const string& target = node->dependencies()[i]->full_path();
    const Node* dep = parser.GetNode(target);
    if (dep == NULL) {
      LOG(FATAL) << "Could not find dependency: " << target
                 << " from target " << node->target().full_path();
    }
    if (parents->find(dep) != parents->end()) {
      LOG(FATAL) << "Recursive dependency: "
                 << target;
    }
    deps->push_back(dep);
    parents->insert(dep);
    GetFullDepList(parser, dep, parents, deps);
    parents->erase(dep);
  }
}

void GetFullDepList(const Parser& parser,
                    const Node* node,
                    vector<const Node*>* deps) {
  set<const Node*> parent;
  parent.insert(node);
  GetFullDepList(parser, node, &parent, deps);
}

}  // namespace

Generator::Generator() {
}

Generator::~Generator() {
}

string Generator::GenerateMakefile(const Input& input) {
  string out = "# Auto-generated by repobuild, do not modify directly.\n\n";

  repobuild::Parser parser;
  parser.Parse(input);

  // Write all of the object rules
  for (const Node* node : parser.all_nodes()) {
    vector<const Node*> deps;
    GetFullDepList(parser, node, &deps);
    node->WriteMakefile(input, deps, &out);
  }

  // Write the make clean rule.
  out.append("clean:\n");
  out.append("\trm -rf ");
  out.append(input.object_dir());
  out.append("\n");
  for (const Node* node : parser.all_nodes()) {
    node->WriteMakeClean(input, &out);
  }
  out.append("\n.PHONY: clean\n\n");

  return out;
}

}  // namespace repobuild
