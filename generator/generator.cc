// Copyright 2013
// Author: Christopher Van Arsdale

#include <set>
#include <vector>
#include <string>
#include "common/log/log.h"
#include "repobuild/env/input.h"
#include "repobuild/generator/generator.h"
#include "nodes/node.h"
#include "repobuild/reader/parser.h"
#include "repobuild/nodes/cc_library.h"  // TODO(cvanarsdale): clunky, remove.

using std::string;
using std::vector;
using std::set;

namespace repobuild {
namespace {

void GetFullDepList(const Parser& parser,
                    const Node* node,
                    set<const Node*>* parents,
                    vector<const Node*>* deps) {
  for (int i = 0; i < node->dependencies().size(); ++i) {
    const string& target = node->dependencies()[i]->full_path();
    const Node* dep = parser.GetNode(target);
    if (dep == NULL) {
      LOG(FATAL) << "Could not find dependency: " << target
                 << " from target " << node->target().full_path();
    }
    if (parents->find(dep) != parents->end()) {
      LOG(FATAL) << "Recursive dependency: "
                 << target;
    }
    deps->push_back(dep);
    parents->insert(dep);
    GetFullDepList(parser, dep, parents, deps);
    parents->erase(dep);
  }
}

void GetFullDepList(const Parser& parser,
                    const Node* node,
                    vector<const Node*>* deps) {
  set<const Node*> parent;
  parent.insert(node);
  GetFullDepList(parser, node, &parent, deps);
}

}  // namespace

Generator::Generator() {
}

Generator::~Generator() {
}

string Generator::GenerateMakefile(const Input& input) {
  string out = "# Auto-generated by repobuild, do not modify directly.\n\n";

  repobuild::Parser parser;
  parser.Parse(input);

  // TODO(cvanarsdale): Make this part of the parser's static registry?
  CCLibraryNode::WriteMakeHead(input, &out);

  // Write all of the rules for our user inputted targets.
  set<const Node*> all_nodes, processed;
  for (const Node* node : parser.input_nodes()) {
    if (processed.insert(node).second) {
      vector<const Node*> deps;
      GetFullDepList(parser, node, &deps);
      for (const Node* dep : deps) {
        all_nodes.insert(dep);
      }
      node->WriteMakefile(deps, &out);
    }
  }

  // Write all of the dependent rules.
  for (const Node* node : all_nodes) {
    if (processed.insert(node).second) {
      vector<const Node*> deps;
      GetFullDepList(parser, node, &deps);
      node->WriteMakefile(deps, &out);
    }
  }

  // Write the make clean rule.
  out.append("clean:\n");
  for (const Node* node : all_nodes) {
    node->WriteMakeClean(&out);
  }
  out.append("\trm -rf ");
  out.append(input.object_dir());
  out.append("\n");
  out.append("\trm -rf ");
  out.append(input.genfile_dir());
  out.append("\n\trm -rf ");
  out.append(input.source_dir());
  out.append("\n");
  out.append("\n");

  // Write the all rule.
  out.append("all:");
  set<string> outputs;
  for (const Node* node : parser.all_nodes()) {
    if (input.contains_target(node->target().full_path())) {
      vector<string> node_out;
      node->FinalOutputs(&node_out);
      for (const string& output : node_out) {
        outputs.insert(output);
      }
      outputs.insert(node->target().make_path());
    }
  }
  for (const string& out_target : outputs) {
    out.append(" ");
    out.append(out_target);
  }
  out.append("\n\n");

  // Not real files:
  out.append(".PHONY: clean all\n\n");

  // Default build everything.
  out.append(".DEFAULT_GOAL=all\n\n");

  return out;
}

}  // namespace repobuild
